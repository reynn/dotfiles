#!/usr/bin/env zsh

#+============================================================================+
# Dotfiles specials
#+============================================================================+

function update_dotfiles() {
  local tags=""
  local verbosity=''
  local debug_mode='no'
  while getopts "dht:v" opt; do
    case $opt in
    d) debug_mode='yes' ;;
    t) if test $tags; then tags+=",$OPTARG"; else tags+="$OPTARG"; fi ;;
    v) verbosity+='v' ;;
    h)
      echo "Usage: ${0:t} [-t TAG] [-v]"
      return 0
      ;;
    esac
  done

  local args=(
    $DFP/ansible/config.yaml
  )

  if test $debug_mode = 'yes'; then
    args+=("-e debug_mode=yes")
  fi

  if test $verbosity; then
    args+=("-$verbosity")
  fi

  if test $tags; then
    args+=(
      '--tags'
      $tags
    )
  fi

  echo "args: $args"
  ANSIBLE_CONFIG=$DFP/ansible/ansible.cfg ansible-playbook ${args[@]}
}

function load_plugin() {
  antibody bundle robbyrussell/oh-my-zsh path:plugins/$1
}

function import_zsh_files() {
  for d in $@; do
    test -d $d || continue
    print_debug $d 'dir'
    local importable=()

    if test -r $DIR_BINS/fd; then
      print_debug 'using fd'
      importable+=($(fd -I -H -t f . $d))
    else
      print_debug 'using find'
      importable+=($(find "$d" -type f))
    fi

    for f in $importable; do
      print_debug $f 'file'
      source $f
    done
  done
}

function update_completions() {
  local RELOAD='false'

  while getopts "hvr" opt; do
    case $opt in
    r) RELOAD='yes' ;;
    h) echo "Usage: ${0:t}" ;;
    esac
  done

  # Update custom completions that I dont want toupdate through a different management tool
  local completion_urls=(
    "https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/zsh/_docker-compose"
    "https://raw.githubusercontent.com/docker/cli/v$(docker version -f '{{.Client.Version}}')/contrib/completion/zsh/_docker"
  )

  for url in $completion_urls; do
    print_info $url 'source'
    local out_full="$DFP/zsh/.completions/$out_file${url##*/}.zsh"
    print_debug $out_full 'out_full'
    curl -L $url --progress-bar -o $out_full
    chmod +x $out_full
  done

  if test $RELOAD = 'yes'; then
    print_info 'reloading your shell'
    autoload -Uz compinit && compinit -i
    exec $SHELL -l
  fi
}

function debug_call() {
  set -x
  $@
  set +x
}

# -----------------------------------------------------------------------------
# UNIX functions --------------------------------------------------------------
# -----------------------------------------------------------------------------

function zsudo() {
  sudo -E zsh -c "$functions[$1]" "$@"
}

function mkcd() {
  mkdir -p "$@" && cd "$_"
}

function slice_arr() {
  local i=$1
  local arr=($@)
  echo ${arr[@]:${i}}
}

function tmux_connect() {
  ssh $1 -t "TERM=xterm-256color tmux new-session -s ssh-sess || tmux attach-session -t ssh-sess"
}

function listen_port() {
  local port=$1
  lsof -nP -i4TCP:$port | grep LISTEN | awk '{ print $2 }'
}

function kill_listening() {
  local port=$1
  if test -z $port; then
    print_usage_json "$0"
    return 0
  fi
  local process=$(listen_port $port)

  print_info "$process" 'process_id'
  sudo kill -9 $process
}

function check_cmd() {
  test -x "$(command -v $1)"
}

function dig_ip() {
  dig +nocmd "$1" A +noall +answer | grep -v 'CNAME' | awk '{print $5}' | head -n 1
}

# Run `dig` and display the most useful info
function digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
  if [ $# -eq 0 ]; then
    open .
  else
    open "$@"
  fi
}

function auto_retry() {
  false
  while [ $? -ne 0 ]; do
    "$@" || (
      sleep 3
      false
    )
  done
}

function ssh_auto_retry() {
  auto_retry ssh "$@"
}

function length() {
  echo "$#"
}

function bin_completion() {
  local bins=(minikube kubectl helm)
  local in=($@)
  if [ "$(length $in)" -gt "0" ]; then
    print_debug 'overriding defaults...'
    bins=($@)
  fi
  for bin in $bins; do
    print_info "Sourcing completions for $bin"
    source <($bin completion zsh)
  done
}

function get_process_environment() {
  local filter="$1"
  if test -z $filter; then
    echo "Must provide a filter to ps aux | grep"
    return 1
  fi
  local process_ids=($(ps aux | grep $filter | grep -v grep | awk '{print $2}'))
  for pid in $process_ids; do
    print_info "Getting environment info for process $pid"
    cat "/proc/$pid/environ" | tr '\0' '\n'
  done
}
