#!/usr/bin/env zsh

#+============================================================================+
# Dotfiles specials
#+============================================================================+

function update_dotfiles {
  local tags=""
  local verbosity=''
  while getopts "ht:v" opt; do
    case $opt in
      t) if test $tags; then tags+=",$OPTARG"; else tags+="$OPTARG"; fi ;;
      v) verbosity+='v' ;;
      h)
        echo "Usage: ${0:t} [-t TAG] [-v]"
        return 0 ;;
    esac
  done
  local args=(
    $DFP/ansible/config.yaml
  )
  if test $verbosity; then
    args+=("-$verbosity")
  fi

  if test $tags; then
    args+=(
      '--tags'
      $tags
    )
  fi
  echo "args: $args"
  ANSIBLE_CONFIG=$DFP/ansible/ansible.cfg ansible-playbook ${args[@]}
}

function load_plugin {
  antibody bundle robbyrussell/oh-my-zsh path:plugins/$1
}

function import_zsh_files {
  for d in $@; do
    test -d $d || continue
    print_debug $d 'dir'
    for f in $(fd -I -H -t f . $d); do
      print_debug $f 'file'
      source $f
    done
  done
}

function debug_call {
  set -x; $@; set +x;
}

# -----------------------------------------------------------------------------
# UNIX functions --------------------------------------------------------------
# -----------------------------------------------------------------------------

function zsudo {
  sudo -E zsh -c "$functions[$1]" "$@"
}

function mkcd {
  mkdir -p "$@" && cd "$_"
}

function slice_arr {
  local i=$1
  local arr=($@)
  echo ${arr[@]:${i}}
}

function tmux_connect {
  ssh $1 -t "TERM=xterm-256color tmux new-session -s ssh-sess || tmux attach-session -t ssh-sess"
}

function listen_port {
  local port=$1
  lsof -nP -i4TCP:$port | grep LISTEN | awk '{ print $2 }'
}

function kill_listening {
  local port=$1
  if test -z $port; then
    print_usage_json "$0"
    return 0
  fi
  local process=$(listen_port $port)

  print_info "$process" 'process_id'
  sudo kill -9 $process
}

function check_cmd {
  test -x "$(command -v $1)"
}

function dig_ip {
  dig +nocmd "$1" A +noall +answer | grep -v 'CNAME' | awk '{print $5}' | head -n 1
}

# Run `dig` and display the most useful info
function digga {
  dig +nocmd "$1" any +multiline +noall +answer
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o {
  if [ $# -eq 0 ]; then
    open .
  else
    open "$@"
  fi
}

function auto_retry {
  false
  while [ $? -ne 0 ]; do
    "$@" || (
      sleep 3
      false
    )
  done
}

function ssh_auto_retry {
  auto_retry ssh "$@"
}

function length {
  echo "$#"
}

function bin_completion {
  local bins=(minikube kubectl helm)
  local in=($@)
  if [ "$(length $in)" -gt "0" ]; then
    print_debug 'overriding defaults...'
    bins=($@)
  fi
  for bin in $bins; do
    print_info "Sourcing completions for $bin"
    source <($bin completion zsh)
  done
}

function get_process_environment {
  local filter="$1"
  if test -z $filter; then
    echo "Must provide a filter to ps aux | grep"
    return 1
  fi
  local process_ids=($(ps aux | grep $filter | grep -v grep | awk '{print $2}'))
  for pid in $process_ids; do
    print_info "Getting environment info for process $pid"
    cat "/proc/$pid/environ" | tr '\0' '\n'
  done
}
